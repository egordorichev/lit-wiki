"use strict";(self.webpackChunklit_wiki=self.webpackChunklit_wiki||[]).push([[308],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},l=Object.keys(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)n=l[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),u=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),c=u(n),m=a,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||l;return n?i.createElement(h,o(o({ref:t},p),{},{components:n})):i.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=c;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:a,o[1]=r;for(var u=2;u<l;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6019:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return r},metadata:function(){return u},toc:function(){return d}});var i=n(7462),a=n(3366),l=(n(7294),n(3905)),o=["components"],r={},s="CLI arguments",u={unversionedId:"cli_arguments",id:"cli_arguments",title:"CLI arguments",description:"Lit CLI has arguments, that you pass to it in order to manipulate its behaviour. You can get a list of them via --help argument:",source:"@site/docs/cli_arguments.md",sourceDirName:".",slug:"/cli_arguments",permalink:"/lit-wiki/docs/cli_arguments",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cli_arguments.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bytecode",permalink:"/lit-wiki/docs/bytecode"},next:{title:"Modules",permalink:"/lit-wiki/docs/modules/"}},p={},d=[{value:"<code>-o --output</code>",id:"-o---output",level:2},{value:"<code>-n --native</code>",id:"-n---native",level:2},{value:"<code>-O -Oall -Ono-all</code>",id:"-o--oall--ono-all",level:2},{value:"Separate optimizations",id:"separate-optimizations",level:3},{value:"Optimization levels",id:"optimization-levels",level:3},{value:"<code>-D</code>",id:"-d",level:2},{value:"<code>-e --eval</code>",id:"-e---eval",level:2},{value:"<code>-p --pass</code>",id:"-p---pass",level:2},{value:"<code>-i --interactive</code>",id:"-i---interactive",level:2},{value:"<code>-d --dump</code>",id:"-d---dump",level:2},{value:"<code>-t --time</code>",id:"-t---time",level:2},{value:"<code>-h --help</code>",id:"-h---help",level:2}],c={toc:d};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,l.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"cli-arguments"},"CLI arguments"),(0,l.kt)("p",null,"Lit CLI has arguments, that you pass to it in order to manipulate its behaviour. You can get a list of them via ",(0,l.kt)("inlineCode",{parentName:"p"},"--help")," argument:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"~ $ lit --help\nlit [options] [files]\n    -o --output [file]  Instead of running the file the compiled bytecode will be saved.\n    -n --native [file]  Instead of running the file the compiled code will be embeded into a native runner.\n    -O[name]            Enables given optimization. For the list of aviable optimizations run with -Ohelp\n    -D[name]            Defines given symbol.\n    -e --eval [string]  Runs the given code string.\n    -p --pass [args]    Passes the rest of the arguments to the script.\n    -i --interactive    Starts an interactive shell.\n    -d --dump           Dumps all the bytecode chunks from the given file.\n    -t --time           Measures and prints the compilation timings.\n    -h --help           I wonder, what this option does.\n")),(0,l.kt)("p",null,"If no code to run is provided, lit will try to run either ",(0,l.kt)("inlineCode",{parentName:"p"},"main.lbc")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"main.lit")," and, if it fails, defaults to an interactive shell."),(0,l.kt)("h2",{id:"-o---output"},(0,l.kt)("inlineCode",{parentName:"h2"},"-o --output")),(0,l.kt)("p",null,"This argument prevents CLI from executing provided code, instead it will be only compiled and saved to the given path.\nYou can always run the saved bytecode later on:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"lit main.lit -o main.lbc\nlit main.lbc\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},".lbc")," extension stands for lit bytecode. You can read more about it in the ",(0,l.kt)("a",{parentName:"p",href:"/docs/bytecode"},"Bytecode")," section."),(0,l.kt)("h2",{id:"-n---native"},(0,l.kt)("inlineCode",{parentName:"h2"},"-n --native")),(0,l.kt)("p",null,"This argument is similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"--output"),", but instead of saving the raw bytecode it downloads lit sourcecode, compiles it with the bytecode embedded into a special runner.\n",(0,l.kt)("em",{parentName:"p"},"Note: this option is only supported on linux for now.")),(0,l.kt)("h2",{id:"-o--oall--ono-all"},(0,l.kt)("inlineCode",{parentName:"h2"},"-O -Oall -Ono-all")),(0,l.kt)("p",null,"This argument controls optimization levels and separate optimizations. You can always get a hint with ",(0,l.kt)("inlineCode",{parentName:"p"},"lit -Ohelp"),". Here are all the supported optimization parameters:"),(0,l.kt)("h3",{id:"separate-optimizations"},"Separate optimizations"),(0,l.kt)("p",null,"You can tweak how lits optimizer behaves in great detail, here are the options that you can play around with:"),(0,l.kt)("table",null,(0,l.kt)("tr",null,(0,l.kt)("td",null,"constant-folding"),(0,l.kt)("td",null,"Replaces constants in code with their values.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"literal-folding"),(0,l.kt)("td",null,"Precalculates literal expressions (3 + 4 is replaced with 7).")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"unused-var"),(0,l.kt)("td",null,"Removes user-declared all variables, that were not used.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"unreachable-code"),(0,l.kt)("td",null,"Removes code that will never be reached.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"empty-body"),(0,l.kt)("td",null,"Removes loops with empty bodies.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"line-info"),(0,l.kt)("td",null,"Removes line information from chunks to save on space.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"private-names"),(0,l.kt)("td",null,"Removes names of the private locals from modules (they are indexed by id at runtime).")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"c-for"),(0,l.kt)("td",null,"Replaces for-in loops with c-style for loops where it can."))),(0,l.kt)("p",null,"To enable an optimization, for example ",(0,l.kt)("inlineCode",{parentName:"p"},"line-info"),", prefix it with just the ",(0,l.kt)("inlineCode",{parentName:"p"},"-O")," part:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"lit main.lit -Oline-info\n")),(0,l.kt)("p",null,"And to disable an optimization you need to prefix it with ",(0,l.kt)("inlineCode",{parentName:"p"},"-Ono-"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"lit main.lit -Ono-line-info\n")),(0,l.kt)("h3",{id:"optimization-levels"},"Optimization levels"),(0,l.kt)("p",null,"But before you start trying to tweak every single optimization option by hand, consider having a look at built-in optimization levels."),(0,l.kt)("table",null,(0,l.kt)("tr",null,(0,l.kt)("td",null,"Level\xa00"),(0,l.kt)("td",null,"No optimizations (same as -Ono-all)")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Level\xa01"),(0,l.kt)("td",null,"Super light optimizations, sepcific to interactive shell.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Level\xa02"),(0,l.kt)("td",null,"(default) Recommended optimization level for the development.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Level\xa03"),(0,l.kt)("td",null,"Medium optimization, recommended for the release.")),(0,l.kt)("tr",null,(0,l.kt)("td",null,"Level\xa04"),(0,l.kt)("td",null,"(default for bytecode) Extreme optimization, throws out most of the variable/function names, used for bytecode compilation."))),(0,l.kt)("p",null,"To activate a level, prefix it with ",(0,l.kt)("inlineCode",{parentName:"p"},"-O"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"lit main.lit -O3\n")),(0,l.kt)("h2",{id:"-d"},(0,l.kt)("inlineCode",{parentName:"h2"},"-D")),(0,l.kt)("p",null,"This argument defines a symbol as if you've inserted ",(0,l.kt)("inlineCode",{parentName:"p"},"#define")," into your code. Let's look at this example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-js"},"#ifdef DEBUG\nprint('Running in debug mode!')\n#else\nprint('Running in release mode!')\n#endif\n")),(0,l.kt)("p",null,"Now if we run it without any additional parameters, we will see the release mode message. But if we run it with the ",(0,l.kt)("inlineCode",{parentName:"p"},"-DDEBUG"),":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"~ $ lit -DDEBUG main.lit\nRunning in debug mode!\n")),(0,l.kt)("p",null,"The code acts with the symbol definition in mind."),(0,l.kt)("h2",{id:"-e---eval"},(0,l.kt)("inlineCode",{parentName:"h2"},"-e --eval")),(0,l.kt)("p",null,"This is probably one of the most useful arguments out there, and it is very simple - it just runs the code you pass with it!"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'~ $ lit -e "print(32 * 2)"\n64\n')),(0,l.kt)("h2",{id:"-p---pass"},(0,l.kt)("inlineCode",{parentName:"h2"},"-p --pass")),(0,l.kt)("p",null,"This argument stops the parsing of arguments, and everything that is left will be passed to the script in the ",(0,l.kt)("inlineCode",{parentName:"p"},"args")," array:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'~ $ lit -e "print(args)" --pass hello -e 32\n[ "hello", "-e", 32 ]\n')),(0,l.kt)("h2",{id:"-i---interactive"},(0,l.kt)("inlineCode",{parentName:"h2"},"-i --interactive")),(0,l.kt)("p",null,"Launches an interactive shell, that allows you to input and execute code."),(0,l.kt)("h2",{id:"-d---dump"},(0,l.kt)("inlineCode",{parentName:"h2"},"-d --dump")),(0,l.kt)("p",null,"Instead of executing the compiled code lit will dump its contents and stop:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},'~ $ lit -d main.lit \n^^ main ^^\nconstants:\n   0 "print"\n   1 10\n   2 1\ntext:\n0000    1 GET_GLOBAL   c0 ("print")     1\n0001    | MOVE          2   c1 (10)     0\n0002    | MOVE          3   c2 (1)      0\n0003    | RANGE         2   3   2\n0004    | CALL          1   2   1\n0005    | LOAD_NULL     1   0   0\n0006    | RETURN        1   1   0\nhex:\n0000401F 00404080 004080C0 0100C086 00808064 00000041 00004047 \nvv main vv\n^^ main ^^\nconstants:\n   0 "print"\n   1 10\n   2 1\ntext:\n        print(1 .. 10)\n0000    1 GET_GLOBAL   c0 ("print")     1\n0001    | MOVE          2   c1 (10)     0\n0002    | MOVE          3   c2 (1)      0\n0003    | RANGE         2   3   2\n0004    | CALL          1   2   1\n0005    | LOAD_NULL     1   0   0\n0006    | RETURN        1   1   0\nhex:\n0000401F 00404080 004080C0 0100C086 00808064 00000041 00004047 \nvv main vv\n')),(0,l.kt)("p",null,"To better understand what this all means you can refer to the ",(0,l.kt)("a",{parentName:"p",href:"/docs/bytecode"},"Bytecode")," section."),(0,l.kt)("h2",{id:"-t---time"},(0,l.kt)("inlineCode",{parentName:"h2"},"-t --time")),(0,l.kt)("p",null,"Lit will measure and display the time it takes it to read, preprocess, parse, optimize and emit the code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"~ $ lit main.lit -t\nReading source: 0.059ms\n-----------------------\nPreprocessing:  0.001ms\nParsing:        0.014ms\nOptimization:   0.002ms\nEmitting:       0.076ms\n\nTotal:          0.167ms\n-----------------------\n")),(0,l.kt)("h2",{id:"-h---help"},(0,l.kt)("inlineCode",{parentName:"h2"},"-h --help")),(0,l.kt)("p",null,"Displays a tiny summary of everything said above."))}m.isMDXComponent=!0}}]);